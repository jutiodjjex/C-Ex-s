<h2>Циклы в C++</h2>

Иногда необходимо повторять одно и то же действие несколько раз подряд. Для этого используют циклы.

- **Цикл for**
Если мы знаем точное количество действий (итераций) цикла, то можем использовать цикл for. Синтаксис его выглядит примерно так:

```c++
for (действие до начала цикла; условие продолжения цикла;  действия в конце каждой итерации цикла) {
         инструкция цикла;
         инструкция цикла 2;
         инструкция цикла N;
}
```

Итерацией цикла называется один проход этого цикла

Существует частный случай этой записи, который мы разберем:

```c++
for (счетчик = значение; счетчик < значение; шаг цикла) {
    тело цикла;
}
```

**Счетчик цикла** — это переменная, в которой хранится количество проходов данного цикла.

**Описание синтаксиса**

  - Сначала присваивается первоначальное значение счетчику, после чего ставится точка с запятой.

  - Затем задается конечное значение счетчика цикла. После того, как значение счетчика достигнет указанного предела, цикл завершится. Снова ставим точку с запятой.

  - Задаем шаг цикла. Шаг цикла — это значение, на которое будет увеличиваться или уменьшаться счетчик цикла при каждом проходе.
  
  **Пример кода**

Напишем программу, которая будет считать сумму всех чисел от 1 до 1000.

```c++
#include <iostream>
using namespace std;

int main()
{
    int i; // счетчик цикла
    int sum = 0; // сумма чисел от 1 до 1000.
    setlocale(0, "");
    for (i = 1; i <= 1000; i++) // задаем начальное значение 1, конечное 1000 и задаем шаг цикла - 1.
    {
        sum = sum + i;
    }
    cout << "Сумма чисел от 1 до 1000 = " << sum << endl;         
    return 0;
}
```

Если мы скомпилируем этот код и запустим программу, то она покажет нам ответ: 500500. Это и есть сумма всех целых чисел от 1 до 1000. Если считать это вручную, понадобится очень много времени и сил. Цикл выполнил всю рутинную работу за нас. <br>

Заметьте, что конечное значение счетчика я задал нестрогим неравенством ( <= — меньше либо равно), поскольку, если бы я поставил знак меньше, то цикл произвел бы 999 итераций, т.е. на одну меньше, чем требуется. Это довольно важный момент, т.к. здесь новички часто допускают ошибки, особенно при работе с массивами (о них будет рассказано в следующем уроке). Значение шага цикла я задал равное единице. i++ — это тоже самое, что и i = i + 1. <br>

В теле цикла, при каждом проходе программа увеличивает значение переменной sum на i. Еще один очень важный момент — в начале программы я присвоил переменной sum значение нуля. Если бы я этого не сделал, программа вылетела вы в сегфолт. При объявлении переменной без ее инициализации что эта переменная будет хранить «мусор». <br>

Естественно к мусору мы ничего прибавить не можем. Некоторые компиляторы, такие как gcc, инициализирует переменную нулем при ее объявлении. <br>

- **Цикл while**

Когда мы не знаем, сколько итераций должен произвести цикл, нам понадобится цикл while или do...while. Синтаксис цикла while в C++ выглядит следующим образом.

```c++
while (Условие) {
    Тело цикла;
}
```

Данный цикл будет выполняться, пока условие, указанное в круглых скобках является истиной. Решим ту же задачу с помощью цикла while. Хотя здесь мы точно знаем, сколько итераций должен выполнить цикл, очень часто бывают ситуации, когда это значение неизвестно. <br>

Ниже приведен исходный код программы, считающей сумму всех целых чисел от 1 до 1000. <br>

```c++
#include <iostream>
using namespace std;

int main()
{
    setlocale(0, "");
    int i = 0; // инициализируем счетчик цикла.
    int sum = 0; // инициализируем счетчик суммы.
    while (i < 1000)
    {
        i++;
        sum += i;
    }
    cout << "Сумма чисел от 1 до 1000 = " << sum << endl; 
    return 0;
}
```

После компиляции программа выдаст результат, аналогичный результату работы предыдущей программы. Но поясним несколько важных моментов. Я задал строгое неравенство в условии цикла и инициализировал счетчик i нулем, так как в цикле while происходит на одну итерацию больше, потому он будет выполняться, до тех пор, пока значение счетчика перестает удовлетворять условию, но данная итерация все равно выполнится. Если бы мы поставили нестрогое неравенство, то цикл бы закончился, когда переменная i стала бы равна 1001 и выполнилось бы на одну итерацию больше. <br>

Теперь давайте рассмотрим по порядку исходный код нашей программы. Сначала мы инициализируем счетчик цикла и переменную, хранящую сумму чисел. <br>

В данном случае мы обязательно должны присвоить счетчику цикла какое-либо значение, т.к. в предыдущей программе мы это значение присваивали внутри цикла for, здесь же, если мы не инициализируем счетчик цикла, то в него попадет «мусор» и компилятор в лучшем случае выдаст нам ошибку, а в худшем, если программа соберется — сегфолт практически неизбежен. <br>

Затем мы описываем условие цикла — «пока переменная i меньше 1000 — выполняй цикл». При каждой итерации цикла значение переменной-счетчика i увеличивается на единицу внутри цикла. <br>

Когда выполнится 1000 итераций цикла, счетчик станет равным 999 и следующая итерация уже не выполнится, поскольку 1000 не меньше 1000. Выражение sum += i является укороченной записью sum = sum + i. <br>

После окончания выполнения цикла, выводим сообщение с ответом. <br>

- **Цикл do while**

Цикл do while очень похож на цикл while. Единственное их различие в том, что при выполнении цикла do while один проход цикла будет выполнен независимо от условия. Решение задачи на поиск суммы чисел от 1 до 1000, с применением цикла do while. <br>

```c++
#include <iostream>
using namespace std;

int main ()
{
    setlocale(0, "");
    int i = 0; // инициализируем счетчик цикла.
    int sum = 0; // инициализируем счетчик суммы.
    do {// выполняем цикл.
        i++;
        sum += i;
    } while (i < 1000); // пока выполняется условие.
    cout << "Сумма чисел от 1 до 1000 = " << sum << endl;
    return 0;
}
```
Принципиального отличия нет, но если присвоить переменной i значение, большее, чем 1000, то цикл все равно выполнит хотя бы один проход. <br>

- **Цикл foreach**

Синтаксис цикла foreach следующий:

```c++
for (объявление_элемента : массив)
  стейтмент;
```

Выполняется итерация по каждому элементу массива, присваивая значение текущего элемента массива переменной, объявленной как элемент (объявление_элемента). В целях улучшения производительности объявляемый элемент должен быть того же типа, что и элементы массива, иначе произойдёт неявное преобразование. Рассмотрим простой пример использования цикла foreach для вывода всех элементов массива math: <br>

```c++
#include <iostream>
 
int main()
{
    int math[] = { 0, 1, 4, 5, 7, 8, 10, 12, 15, 17, 30, 41};
    for (int number : math) // итерация по массиву math
       std::cout << number << ' '; // получаем доступ к элементу массива в этой итерации через переменную number
 
    return 0;
}
```

Результат выполнения программы выше:

```c++
0 1 4 5 7 8 10 12 15 17 30 41
```


